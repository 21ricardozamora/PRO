import re
import sqlite3

DB_PATH = ':memory:'


class DbHandler:
    def __init__(self, db_path: str = DB_PATH):
        self.con = sqlite3.connect(db_path)
        self.con.row_factory = sqlite3.Row
        self.cur = self.con.cursor()

    def create_db(self) -> None:
        sql = """
        CREATE TABLE activity (
            id INTEGER PRIMARY KEY,
            sender TEXT,
            recipient TEXT,
            message TEXT
        );
        
        CREATE TABLE access (
            phone_number TEXT PRIMARY KEY,
            pin TEXT,
            puk TEXT
        );
        """
        self.cur.executescript(sql)
        self.con.commit


class SMS(DbHandler):
    def __init__(self, sender: str, recipient: str, message: str):
        super().__init__()
        self.sender = sender
        self.recipient = recipient
        self.message = message

    def send(self) -> None:
        sql = 'INSERT INTO activity (sender, recipient, message) VALUES (?, ?, ?)'      #Envío del sms
        self.cur.execute(sql, (self.sender, self.recipient, self.message))
        self.con.commit()

    def __str__(self):
        return f'From: {self.sender}\nTo: {self.recipient}\n---\n{self.message}'


class SIM(DbHandler):
    def __init__(self, phone_number: str):
        super().__init__()
        self.phone_number = phone_number
        self.unlocked = False

    def unlock(self, pin: str, *, puk: str = '') -> None:
        sql = 'SELECT pin, puk FROM access WHERE phone_number = ?'
        sim_data = self.cur.execute(sql, (self.phone_number,)).fetchone()

        correct_pin = sim_data['pin']
        correct_puk = sim_data['puk']

        if pin == correct_pin or (puk and puk == correct_puk):      #Comprobación del Pin y Puk para desbloquear el teléfono
            self.unlocked = True
        else:
            self.unlocked = False

    @staticmethod
    def unlock_required(method):
        def wrapper(self, *args, **kwargs):
            if not self.unlocked:
                raise SMSError('SMS is locked', self)
            return method(self, *args, **kwargs)

        return wrapper

    @unlock_required
    def send_sms(self, *, recipient: str, message: str) -> None:
        regexp = r'^(\+\d{2} ?)?[67]\d{8}$'
        if not re.fullmatch(regexp, recipient):
            raise SMSError('Recipient has invalid phone format', self)

        sms = SMS(sender=self.phone_number, recipient=recipient, message=message) #Construcción del sms
        sms.send()      #Envío del sms mediante la función sen definida anteriormente

    @unlock_required
    def get_sms(self, sent: bool = True):
        sql1 = 'SELECT message FROM activity WHERE sender = ?'
        sql2 = 'SELECT message FROM activity WHERE recipient = ?'
        if sent:
            self.cur.execute(sql1, (self.phone_number,))
        else:                                               #Se comprueba que sent sea verdadero o falso para que los sms sean enviados, si es verdadero, se envían a sender, si es falso, a recipient
            self.cur.execute(sql2, (self.phone_number,))

        for row in self.cur.fetchall():
            yield SMS(sender=row['sender'], recipient=row['recipient'], message=row['message'])         #función generadora, usar fetchall() para recorrer todas las columnas


class SMSError(Exception):
    def __init__(self, message: str, db_handler: DbHandler):
        super().__init__(message)
        db_handler.con.close()          #Cerrar conexión
